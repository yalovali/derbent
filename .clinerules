# Cline Rules for Derbent Project

You are working on Derbent, a Java 21 Spring Boot + Vaadin 24.8 project management application.

## CRITICAL: Environment Setup
ALWAYS run this FIRST in every session:
```bash
source ./setup-java-env.sh
```
This configures Java 21 which is REQUIRED by the project.

## Mandatory Coding Rules

### 1. C-Prefix Convention (NO EXCEPTIONS)
ALL custom classes MUST start with "C":
```java
✅ CActivity, CUser, CProject
✅ CActivityService, CUserService
✅ CActivityView, CUserPage
✅ CButton, CGrid, CDialog

❌ Activity, User, Project (WRONG!)
❌ ActivityService (WRONG!)
```

Only exceptions:
- Interfaces: IActivityRepository, IUserService (use I-prefix)
- Tests: CActivityTest (keep C-prefix)

### 2. UI Component Field Naming (typeName Convention - MANDATORY)
ALL UI component fields MUST follow `{type}{Name}` format:
```java
// ✅ CORRECT
private CButton buttonAdd;              // button{Name}
private CButton buttonDelete;           // button{Name}
private CDialog dialogConfirmation;     // dialog{Name}
private CVerticalLayout layoutMain;     // layout{Name}
private CGrid<CEntity> gridItems;       // grid{Name}
private ComboBox<String> comboBoxStatus; // comboBox{Name}

// ❌ WRONG
private CButton addBtn;                 // Wrong!
private CButton btn_delete;             // Wrong!
private HorizontalLayout toolbar;       // Wrong! Use CHorizontalLayout layoutToolbar
```

### 3. Event Handler Naming (on_xxx_eventType - MANDATORY)
ALL event handlers MUST follow `on_{componentName}_{eventType}` pattern:
```java
// ✅ CORRECT
protected void on_buttonAdd_clicked() { }
protected void on_buttonDelete_clicked() { }
protected void on_gridItems_selected(CEntity item) { }
protected void on_gridItems_doubleClicked(CEntity item) { }
protected void on_comboBoxStatus_changed(String status) { }

// ❌ WRONG
private void handleAdd() { }            // Wrong!
private void onDeleteClick() { }        // Wrong!
```

### 4. Factory Method Naming (create_xxx - MANDATORY)
ALL component factory methods MUST follow `create_{componentName}` pattern:
```java
// ✅ CORRECT
protected CButton create_buttonAdd() {
    final CButton button = new CButton(VaadinIcon.PLUS.create());
    button.addClickListener(e -> on_buttonAdd_clicked());
    return button;
}

// ❌ WRONG
protected CButton createAddButton() { }  // Wrong!
```

### 5. Never Use Lambda for Complex Logic
ALWAYS delegate to named methods:
```java
// ❌ WRONG - Complex lambda
buttonAdd.addClickListener(e -> {
    // Long complex logic here...
});

// ✅ CORRECT - Delegate to named method
buttonAdd.addClickListener(e -> on_buttonAdd_clicked());
```

### 6. Always Use C-Prefixed Components
NEVER use raw Vaadin components:
```java
// ❌ WRONG
private Button addButton;
private VerticalLayout mainLayout;
private Grid<CEntity> grid;

// ✅ CORRECT
private CButton buttonAdd;
private CVerticalLayout layoutMain;
private CGrid<CEntity> gridItems;
```

### 7. Package Organization
```
tech.derbent.{module}.{layer}

Modules: activities, users, projects, meetings, companies, risks, decisions, comments, orders, workflow, roles
Layers: domain, service, view
```

Examples:
- `tech.derbent.activities.domain.CActivity`
- `tech.derbent.activities.service.CActivityService`
- `tech.derbent.activities.view.CActivityCard`

### 8. Base Classes (Extend These)
- Entity classes → `CEntityDB<T>`, `CProjectItem<T>`, `CEntityOfProject<T>`
- Service classes → `CAbstractService<T>`
- Repository interfaces → `IAbstractRepository<T>`
- View pages → `CAbstractEntityDBPage<T>`, `CAbstractNamedEntityPage<T>`

### 9. Notification System (CRITICAL - No Exceptions)
```java
// ❌ NEVER do this:
Notification.show("message");

// ✅ ALWAYS do this:
@Autowired
private CNotificationService notificationService;

notificationService.showSuccess("Operation completed");
notificationService.showError("Operation failed");
notificationService.showSaveSuccess();
notificationService.showDeleteError();

// For static/utility contexts:
CNotifications.showSuccess("Message");
CNotifications.showError("Message");
```

### 10. Type Safety (Always Use Generics)
```java
// ✅ Correct
public class CActivity extends CProjectItem<CActivity> {}
List<CActivity> activities = service.findAll();

// ❌ Wrong - raw types
public class CActivity extends CProjectItem {}
List activities = service.findAll();
```

## Build & Development Commands

### Initial Setup
```bash
source ./setup-java-env.sh
java -version  # Should show Java 21
mvn -version   # Should show Maven 3.9+
```

### Compilation (15 seconds)
```bash
mvn clean compile
```

### Code Formatting (REQUIRED before commits)
```bash
mvn spotless:apply  # Fix formatting
mvn spotless:check  # Verify formatting
```

### Run Application
```bash
# Development with H2 database (no PostgreSQL needed)
mvn spring-boot:run -Dspring.profiles.active=h2

# Application accessible at: http://localhost:8080
```

### Testing
```bash
# UI tests with screenshots (37-40 seconds)
./run-playwright-tests.sh menu

# Comprehensive test suite (2-5 minutes)
./run-playwright-tests.sh comprehensive
```

## Validation Checklist

Before completing any task:
1. ✅ All custom classes have C-prefix
2. ✅ UI fields follow typeName convention (buttonAdd, gridItems, etc.)
3. ✅ Event handlers follow on_xxx_eventType pattern
4. ✅ Factory methods follow create_xxx pattern
5. ✅ No complex lambda - delegates to named methods
6. ✅ Uses C-prefixed components (not raw Vaadin)
7. ✅ No raw types - generics used everywhere
8. ✅ CNotificationService used (not Notification.show)
9. ✅ Package structure follows module/layer pattern
10. ✅ Code formatted with `mvn spotless:apply`
11. ✅ Project compiles: `mvn clean compile`

## Common Mistakes to Avoid
❌ Forgetting C-prefix on custom classes
❌ Using wrong field names (addBtn instead of buttonAdd)
❌ Using wrong event handler names (handleAdd instead of on_buttonAdd_clicked)
❌ Complex logic in lambda expressions
❌ Using raw Vaadin components (Button instead of CButton)
❌ Using Notification.show() directly
❌ Using raw types without generics
❌ Inconsistent package structure
❌ Not running spotless before commit

## Entity Design Patterns (2026-01 Updates)

### Entity Inheritance Decision Tree
```
Database entity needed?
├─ NO → POJO or Component
└─ YES → CEntityDB<T>
    └─ Needs name? → CEntityNamed<T>
        ├─ Company-scoped (roles, workflows, types)? → CEntityOfCompany<T>
        └─ Project-scoped? → CEntityOfProject<T>
            └─ Work item with workflow? → CProjectItem<T>
```

### Interface vs Inheritance Rules
- **Use inheritance** for: Identity, persistence, IS-A relationships
- **Use interfaces** for: Optional capabilities, behavior contracts, features across hierarchies

Examples:
```java
// ✅ GOOD: Interface for optional capability
public interface ISprintableItem {
    CSprintItem getSprintItem();
    Long getStoryPoint();
    void moveSprintItemToSprint(CSprint sprint);
}

// Entity opts-in to sprint capability
public class CActivity extends CProjectItem<CActivity> 
        implements ISprintableItem {
    @OneToOne(mappedBy = "activity")
    private CSprintItem sprintItem;
}

// ✅ GOOD: Composition over inheritance
// CSprintItem is OWNED by CActivity, not inherited
```

### Lazy Loading Patterns (CRITICAL)

#### Pattern 1: Refresh Detached Entities
```java
protected void on_grid_selectionChanged(SelectionEvent<T> event) {
    T entity = event.getFirstSelectedItem().orElse(null);
    
    // CRITICAL: Refresh to get managed entity
    if (entity != null && entity.getId() != null) {
        entity = service.getById(entity.getId()).orElse(entity);
    }
    
    // Now safe to access lazy fields
    updateToolbar(entity);
}
```

#### Pattern 2: Graceful Fallback
```java
protected List<CStatus> statusProvider(T entity) {
    try {
        return entity.getValidNextStatuses(); // May fail if detached
    } catch (LazyInitializationException | IllegalStateException e) {
        LOGGER.debug("Lazy loading failed, using fallback");
        return statusService.findAll(); // Fallback
    }
}
```

### Story Points & Progress Indicators

Rules:
1. ✅ Always visible (show "0 SP" if null)
2. ✅ Click to edit with inline field
3. ✅ Auto-save on blur/enter
4. ✅ Cancel on escape
5. ✅ Refresh column totals after save

```java
// GOOD: Click-to-edit story point widget
public class CComponentStoryPoint extends CDiv {
    private void on_display_clicked() {
        showEditor();
    }
    
    private void on_editor_blurred() {
        saveAndUpdateDisplay();
        notifyParentToRefreshTotals();
    }
}
```

### Multi-Value Persistence Pattern

For components that need to persist multiple state values:

```java
public class CKanbanBoard implements IHasMultiValuePersistence {
    
    public CKanbanBoard() {
        // Enable with unique namespace
        persist_enable("kanbanBoard_project123");
        
        // Restore state
        persist_getValue("selectedKanbanLine").ifPresent(this::selectLine);
        persist_getValue("expandedColumns").ifPresent(this::expandColumns);
    }
    
    protected void on_kanbanLine_changed(Long lineId) {
        persist_setValue("selectedKanbanLine", lineId.toString());
    }
}
```

### Company-Scoped vs Project-Scoped

**Company-Scoped** (CEntityOfCompany):
- Reusable templates: CRole, CWorkflowBase, CProjectType
- Shared across ALL company projects
- Changes affect all projects

**Project-Scoped** (CEntityOfProject):
- Project-specific: CActivity, CMeeting, CDecision
- Different instances per project
- Project-level configuration

## Testing Requirements (2026-01 Updates)

### Comprehensive Grid Filter Tests
```bash
./run-playwright-tests.sh comprehensive
```

Tests MUST verify:
- ✅ Entity type filter reduces rows
- ✅ Status filter works correctly
- ✅ Assigned to filter works
- ✅ Search filter works
- ✅ Clear button resets ALL filters
- ✅ Screenshots captured at each step

### Story Point Testing
```bash
# Test story point editing in kanban
# Verify: click to edit, auto-save, column total updates
```

Tests MUST verify:
- ✅ Story points visible even when 0
- ✅ Click opens editor
- ✅ Enter/blur saves value
- ✅ Escape cancels edit
- ✅ Column totals refresh immediately

### Lazy Loading Tests
```java
@Test
void testToolbarHandlesDetachedEntity() {
    // Create & save entity
    // Clear session (detach entity)
    // Verify toolbar handles gracefully
    assertDoesNotThrow(() -> toolbar.update(detached));
}
```

## For Complete Details
- Entity design patterns: `docs/architecture/ENTITY_INHERITANCE_AND_DESIGN_PATTERNS.md`
- Comprehensive guidelines: `docs/development/copilot-guidelines.md`
- Full instructions: `.github/copilot-instructions.md`
