# Derbent Project - Cursor IDE Rules

## Project Overview
Derbent is a Java 21 Spring Boot + Vaadin 24.8 project management application.

## Essential Setup
Before coding, ALWAYS run:
```bash
source ./setup-java-env.sh  # Configure Java 21 environment
```

## Coding Standards (MANDATORY)

### 1. C-Prefix Convention
ALL custom classes MUST use "C" prefix:
- ✅ `CActivity`, `CUser`, `CProject`
- ✅ `CActivityService`, `CUserService`
- ✅ `CActivityView`, `CUserPage`
- ❌ `Activity`, `User` (WRONG - missing prefix)

Exceptions:
- Interfaces: Use "I" prefix (`IActivityRepository`)
- Tests: Keep C-prefix (`CActivityTest`)

### 2. UI Component Field Naming (typeName Convention - MANDATORY)
ALL UI component fields MUST follow `{type}{Name}` format:
```java
// ✅ CORRECT
private CButton buttonAdd;              // button{Name}
private CButton buttonDelete;           // button{Name}
private CButton buttonMoveUp;           // button{Name}
private CDialog dialogConfirmation;     // dialog{Name}
private CVerticalLayout layoutMain;     // layout{Name}
private CHorizontalLayout layoutToolbar; // layout{Name}
private CGrid<CEntity> gridItems;       // grid{Name}
private ComboBox<String> comboBoxStatus; // comboBox{Name}
private TextField textFieldName;        // textField{Name}

// ❌ WRONG - Do NOT use
private CButton addBtn;                 // Wrong!
private CButton btn_delete;             // Wrong!
private Button addButton;               // Wrong! Use CButton buttonAdd
private HorizontalLayout toolbar;       // Wrong! Use CHorizontalLayout layoutToolbar
```

### 3. Event Handler Naming (on_xxx_eventType - MANDATORY)
ALL event handlers MUST follow `on_{componentName}_{eventType}` pattern:
```java
// ✅ CORRECT
protected void on_buttonAdd_clicked() { }
protected void on_buttonDelete_clicked() { }
protected void on_buttonMoveUp_clicked() { }
protected void on_gridItems_selected(CEntity item) { }
protected void on_gridItems_doubleClicked(CEntity item) { }
protected void on_comboBoxStatus_changed(String status) { }

// ❌ WRONG - Do NOT use
private void handleAdd() { }            // Wrong!
private void onDeleteClick() { }        // Wrong!
private void processSelection() { }     // Wrong!
```

### 4. Factory Method Naming (create_xxx - MANDATORY)
ALL component factory methods MUST follow `create_{componentName}` pattern:
```java
// ✅ CORRECT
protected CButton create_buttonAdd() {
    final CButton button = new CButton(VaadinIcon.PLUS.create());
    button.addClickListener(e -> on_buttonAdd_clicked());
    return button;
}

protected CButton create_buttonDelete() {
    final CButton button = new CButton(VaadinIcon.TRASH.create());
    button.addClickListener(e -> on_buttonDelete_clicked());
    return button;
}

// ❌ WRONG - Do NOT use
protected CButton createAddButton() { }     // Wrong!
protected CButton getDeleteButton() { }     // Wrong!
```

### 5. Never Use Lambda for Complex Logic
ALWAYS delegate to named methods:
```java
// ❌ WRONG - Complex lambda (hard to read, hard to override)
buttonAdd.addClickListener(e -> {
    // Long complex logic here...
    doThis();
    doThat();
});

// ✅ CORRECT - Delegate to named method
buttonAdd.addClickListener(e -> on_buttonAdd_clicked());
```

### 6. Always Use C-Prefixed Components
NEVER use raw Vaadin components:
| ❌ Wrong | ✅ Correct |
|----------|-----------|
| `Button` | `CButton` |
| `Dialog` | `CDialog` |
| `VerticalLayout` | `CVerticalLayout` |
| `HorizontalLayout` | `CHorizontalLayout` |
| `Grid<T>` | `CGrid<T>` |
| `TextField` | `CTextField` |
| `FormLayout` | `CFormLayout` |

### 7. Package Structure
```
tech.derbent.{module}.{layer}
- module: activities, users, projects, etc.
- layer: domain, service, view
```

Example:
- `tech.derbent.activities.domain.CActivity`
- `tech.derbent.activities.service.CActivityService`
- `tech.derbent.activities.view.CActivityView`

### 8. Inheritance Patterns
Follow established base classes:
- Entities: Extend `CEntityDB<T>`, `CProjectItem<T>`, etc.
- Services: Extend `CAbstractService<T>`
- Views: Extend `CAbstractEntityDBPage<T>`

### 9. Notification System (CRITICAL)
NEVER use direct Vaadin Notification.show(). ALWAYS use:
```java
@Autowired
private CNotificationService notificationService;

notificationService.showSuccess("Operation completed");
notificationService.showError("Operation failed");
notificationService.showSaveSuccess();
notificationService.showDeleteError();
```

For static contexts:
```java
CNotifications.showSuccess("Message");
CNotifications.showError("Message");
```

### 10. Type Safety
Always use generics:
```java
// ✅ Correct
public class CActivity extends CProjectItem<CActivity> {}
List<CActivity> activities = service.findAll();

// ❌ Wrong
public class CActivity extends CProjectItem {}  // Raw type
```

## Build Commands

### Compile (15 seconds)
```bash
mvn clean compile
```

### Format Code (REQUIRED before commit)
```bash
mvn spotless:apply
mvn spotless:check
```

### Run Application (H2 database for development)
```bash
mvn spring-boot:run -Dspring.profiles.active=h2
```

### Run Tests
```bash
./run-playwright-tests.sh menu        # UI tests with screenshots
./run-playwright-tests.sh comprehensive # Full test suite
```

## Validation Checklist

Before completing any task:
1. ✅ All custom classes have C-prefix
2. ✅ UI fields follow typeName convention (buttonAdd, gridItems, etc.)
3. ✅ Event handlers follow on_xxx_eventType pattern
4. ✅ Factory methods follow create_xxx pattern
5. ✅ No complex lambda - delegates to named methods
6. ✅ Uses C-prefixed components (not raw Vaadin)
7. ✅ No raw types - generics used everywhere
8. ✅ CNotificationService used (not Notification.show)
9. ✅ Code formatted with `mvn spotless:apply`
10. ✅ Project compiles: `mvn clean compile`

## Common Mistakes to Avoid
❌ Wrong field names (addBtn instead of buttonAdd)
❌ Wrong handler names (handleAdd instead of on_buttonAdd_clicked)
❌ Complex logic in lambda expressions
❌ Using raw Vaadin components (Button instead of CButton)
❌ Missing C-prefix on custom classes
❌ Direct Notification.show() calls
❌ Forgetting to format with spotless

## Entity Design Patterns (2026-01)

### Entity Inheritance Decision Tree
```
Database entity?
├─ NO → POJO or Component
└─ YES → CEntityDB<T>
    └─ Named? → CEntityNamed<T>
        ├─ Company-scoped? → CEntityOfCompany<T>  // roles, workflows, types
        └─ Project-scoped? → CEntityOfProject<T>
            └─ Work item? → CProjectItem<T>  // activities, meetings, decisions
```

### Interface vs Inheritance
- **Inheritance**: Identity, persistence, IS-A relationships
- **Interfaces**: Optional capabilities, behavior contracts

Example:
```java
// ✅ Interface for optional capability
public interface ISprintableItem {
    CSprintItem getSprintItem();
    void moveSprintItemToSprint(CSprint sprint);
}

// Entity opts-in
public class CActivity extends CProjectItem<CActivity> 
        implements ISprintableItem {
    @OneToOne(mappedBy = "activity")
    private CSprintItem sprintItem;  // Composition, not inheritance
}
```

### Lazy Loading (CRITICAL)
Entities from grids are often detached. ALWAYS refresh before accessing lazy fields:

```java
protected void on_grid_selected(T entity) {
    // Refresh to get managed entity
    if (entity != null && entity.getId() != null) {
        entity = service.getById(entity.getId()).orElse(entity);
    }
    // Now safe to access lazy fields
}
```

Graceful fallback:
```java
try {
    return entity.getValidNextStatuses();  // May fail if detached
} catch (LazyInitializationException e) {
    return statusService.findAll();  // Fallback
}
```

### Story Points & Progress
Rules:
1. Always visible (show "0 SP" if null)
2. Click to edit
3. Auto-save on blur/enter, cancel on escape
4. Refresh column totals after save

### Multi-Value Persistence
For components with multiple state values:

```java
public class CKanbanBoard implements IHasMultiValuePersistence {
    public CKanbanBoard() {
        persist_enable("kanbanBoard_project123");
        persist_getValue("selectedLine").ifPresent(this::selectLine);
    }
    
    protected void on_line_changed(Long lineId) {
        persist_setValue("selectedLine", lineId.toString());
    }
}
```

## Testing Requirements (2026-01)

### Grid Filter Tests
```bash
./run-playwright-tests.sh comprehensive
```

Must verify:
- ✅ Entity type filter works
- ✅ Status filter works
- ✅ Assigned to filter works
- ✅ Search filter works
- ✅ Clear resets ALL filters
- ✅ Screenshots captured

### Story Point Tests
Must verify:
- ✅ Always visible (even when 0)
- ✅ Click opens editor
- ✅ Enter/blur saves
- ✅ Escape cancels
- ✅ Column totals update

### Lazy Loading Tests
```java
@Test
void testDetachedEntity() {
    // Create, save, detach entity
    // Verify toolbar handles gracefully
    assertDoesNotThrow(() -> toolbar.update(detached));
}
```

## Documentation
- Entity patterns: `docs/architecture/ENTITY_INHERITANCE_AND_DESIGN_PATTERNS.md`
- Development guide: `docs/development/copilot-guidelines.md`
- Full instructions: `.github/copilot-instructions.md`
